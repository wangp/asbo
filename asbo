#!/bin/zsh -e

readonly REPO=${REPO:-/var/lib/sbopkg/SBo/14.0}
readonly CACHEDIR=${CACHEDIR:-/tmp/sbo/cache}
readonly STAGEDIR=${STAGEDIR:-/tmp/sbo/stage}
readonly LOGDIR=${LOGDIR:-/tmp/sbo/log}
readonly SLACKBUILD_SHELL=/bin/bash
readonly FAKEROOT=/usr/bin/fakeroot
readonly SUDO=/usr/bin/sudo
readonly PKGDB=/var/log/packages

#-----------------------------------------------------------------------------#

debug() {
    # print "DEBUG: $@" 1>&2
}

warn() {
    print "Warning: $@" 1>&2
}

die() {
    print "Error: $@" 1>&2
    exit 1
}

#-----------------------------------------------------------------------------#

detect_arch() {
    case "$( uname -m )" in
        i?86) echo "x86" ;;
           *) echo $( uname -m ) ;;
    esac
}

readonly ARCH=${ARCH:-$(detect_arch)}

#-----------------------------------------------------------------------------#

find_pkg_dir() {
    local pkg pkg_dir
    pkg=$1
    pkg_dir=( $REPO/*/$pkg(N) )
    if [[ $#pkg_dir == 0 ]]
    then
        die "$pkg not found"
    fi
    print -- $pkg_dir[1]
}

#-----------------------------------------------------------------------------#

split_pkg_name() {
    local longname=${1:t}
    if [[ $longname =~ \(.*\)-\([^-]*\)-\([^-]*\)-\(.*\) ]]
    then
        print -- $match
    else
        print -- $longname
    fi
}

same_version_installed() {
    local -r pkg=$1
    local -r pkg_dir=$(find_pkg_dir $pkg)
    local -r info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    local found
    found=( $PKGDB/$PRGNAM-$VERSION-*-*(N) )
    if [[ $#found > 0 ]]
    then
        return 0
    fi
    return 1
}

some_version_installed() {
    local -r pkg=$1
    local file
    for file in $PKGDB/${pkg}*(N)
    do
        local split
        split=($( split_pkg_name $file ))
        if [[ $split[1] == $pkg ]]
        then
            return 0
        fi
    done
    return 1
}

#-----------------------------------------------------------------------------#

seen=()
queue=()

is_seen() {
    for x in $seen
    do
        if [[ $x == $1 ]]
        then
            return 0
        fi
    done
    return 1
}

in_queue() {
    for q in $queue
    do
        if [[ $q == $1 ]]
        then
            return 0
        fi
    done
    return 1
}

add_deps() {
    local pkg=$1
    local pkg_dir=$(find_pkg_dir $pkg)
    [[ -d $pkg_dir ]] || exit 1
    local info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    seen+=$pkg
    debug "seen $pkg"
    local req
    for req in ${=REQUIRES}
    do
        if [[ $req == "%README%" ]]
        then
            continue
        fi
        if in_queue $req
        then
            debug "$req already queued"
            continue
        fi
        if is_seen $req
        then
            die "circular dependency detected: $req"
        fi
        add_deps $req
    done
    debug "$pkg queued"
    queue+=$pkg
}

#-----------------------------------------------------------------------------#

verify_file() {
    local md5=$1
    local fn=$2
    if [[ -f $fn ]]
    then
        local digest=$( md5sum $fn | cut -d' ' -f1 )
        if [[ $digest == $md5 ]]
        then
            debug "file exists and verified: $fn"
            return 0
        else
            warn "MD5 sum does not match: $fn"
        fi
    else
        debug "file does not exist: $fn"
    fi
    return 1
}

download_src() {
    local pkg=$1
    local pkg_dir=$(find_pkg_dir $pkg)
    local info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    local md5s srcs
    if [[ $ARCH == x86_64 && -n $DOWNLOAD_x86_64 ]]
    then
        srcs=( ${=DOWNLOAD_x86_64} )
        md5s=( ${=MD5SUM_x86_64} )
    else
        srcs=( ${=DOWNLOAD} )
        md5s=( ${=MD5SUM} )
    fi

    local -a srcfns
    while (( $#md5s > 0 ))
    do
        local src=$srcs[1]
        local md5=$md5s[1]
        local srcfn=${src:t}
        shift srcs
        shift md5s
        if ! verify_file $md5 $srcfn
        then
            debug "need to download: $srcfn"
            rm -f $srcfn
            if ! wget $src
            then
                die "failed to download $src"
            fi
            if ! verify_file $md5 $srcfn
            then
                die "MD5 sum does not match: $srcfn"
            fi
        fi
        srcfns+=$srcfn
    done

    if (( $#dls > 0 ))
    then
        die "list length mismatch"
    fi

    print -l -- $srcfns
}

#-----------------------------------------------------------------------------#

maybe_fakeroot() {
    if [[ $UID != 0 && -x $FAKEROOT ]]
    then
        debug "running $FAKEROOT $@ in $PWD"
        command $FAKEROOT "$@"
        return $?
    else
        debug "running $@"
        command "$@"
        return $?
    fi
}

build() {
    local -r pkg=$1
    local -r pkg_dir=$(find_pkg_dir $pkg)
    local -r stagedir=$STAGEDIR/$pkg
    shift 1

    rm -rf $stagedir
    mkdir -p $stagedir
    cp -r $pkg_dir/* $stagedir
    local fn
    for fn in "$@"
    do
        ln -s $CACHEDIR/$fn $stagedir
    done

    cd $stagedir
    if ! maybe_fakeroot $SLACKBUILD_SHELL $pkg.SlackBuild
    then
        die "error building $pkg"
    fi
}

#-----------------------------------------------------------------------------#

extract_built_pkg_filename() {
    local -r logfile=$1
    tail -3 $logfile | grep '^Slackware package .* created[.]$' | cut -d' ' -f3
}

maybe_sudo() {
    if [[ $UID != 0 && -x $SUDO ]]
    then
        debug "running $SUDO $@"
        command $SUDO "$@"
        return $?
    else
        debug "running $@"
        command "$@"
        return $?
    fi
}

install() {
    maybe_sudo /sbin/upgradepkg --install-new --reinstall $1
}

#-----------------------------------------------------------------------------#

# Parse options

mode_checkupdates=0
mode_dryrun=0
mode_download=0
mode_build=0
mode_install=0
mode_rebase=0

while getopts cndbir OPT
do
    case $OPT in
        (c)
            mode_checkupdates=1
            ;;
        (n)
            mode_dryrun=1
            ;;
        (d)
            mode_download=1
            ;;
        (b)
            mode_download=1
            mode_build=1
            ;;
        (i)
            mode_download=1
            mode_build=1
            mode_install=1
            ;;
        (r)
            mode_rebase=1
            ;;
        (?)
            die "unrecognised option"
            ;;
    esac
done
shift $(( $OPTIND - 1 ))

case $mode_checkupdates,$mode_download,$mode_build,$mode_install,$mode_rebase in
    (0,0,0,0,0)
        # Default to -i.
        mode_download=1
        mode_build=1
        mode_install=1
        ;;
esac

#-----------------------------------------------------------------------------#

if (( $mode_rebase ))
then
    print -- "Updating repository:  git pull --rebase"
    cd $REPO
    exec git pull --rebase
fi

#-----------------------------------------------------------------------------#

checkupdates() {
    local file split
    for file in $PKGDB/*_SBo(N)
    do
        split=($( split_pkg_name $file ))
        local pkg=$split[1]
        local installed_version=$split[2]
        # XXX should not die if not found
        local pkg_dir=$(find_pkg_dir $pkg)
        if [[ ! -d $pkg_dir ]]
        then
            print -- "$pkg not in SlackBuilds repository"
            continue
        fi
        local info=$pkg_dir/$pkg.info
        . $info # XXX makes a mess

        if [[ $VERSION != $installed_version ]]
        then
            print -- "$pkg $VERSION"
            print -- "\t${file:t}"
            print
        fi
    done
}

if (( $mode_checkupdates ))
then
    checkupdates
    exit 0
fi

#-----------------------------------------------------------------------------#

top_pkg=$1

if [[ -z $top_pkg ]]
then
    die "no top-level package specified"
fi

add_deps $top_pkg

if (( $mode_dryrun ))
then
    print "Would build packages in this order:"
    print "  $queue"
    exit 0
fi

mkdir -p $CACHEDIR
mkdir -p $STAGEDIR
mkdir -p $LOGDIR

for pkg in $queue
do
    if [[ $pkg == $top_pkg ]]
    then
        if same_version_installed $pkg
        then
            print -- "$pkg (same version) already installed, skipping."
            continue
        fi
    elif some_version_installed $pkg
    then
        print -- "$pkg already installed, skipping."
        continue
    fi

    cd $CACHEDIR
    local logfile=$LOGDIR/$pkg.log
    local -a srcfns
    srcfns=($( download_src $pkg ))

    if (( $mode_build ))
    then
        print "Building $pkg"
        if ! build $pkg $srcfns 2>&1 | tee $logfile
        then
            die "build failed"
        fi
    fi

    if (( $mode_install ))
    then
        print "Installing $pkg (enter sudo password if required)"
        install $(extract_built_pkg_filename $logfile)
    fi
done

#-----------------------------------------------------------------------------#
# vim: set sts=4 sw=4 et:

#!/bin/zsh -e

readonly GIT_URL="git://slackbuilds.org/slackbuilds"
readonly SLACKBUILD_SHELL=/bin/bash
readonly FAKEROOT=/usr/bin/fakeroot
readonly SUDO=/usr/bin/sudo
readonly PKGDB=/var/log/packages
readonly PAGER=${PAGER:-more}

#-----------------------------------------------------------------------------#

debug() {
    # print "DEBUG: $@" 1>&2
}

warn() {
    print "Warning: $@" 1>&2
}

die() {
    print "Error: $@" 1>&2
    exit 1
}

#-----------------------------------------------------------------------------#

detect_arch() {
    case "$( uname -m )" in
        i?86) echo "x86" ;;
           *) echo $( uname -m ) ;;
    esac
}

readonly ARCH=${ARCH:-$(detect_arch)}

#-----------------------------------------------------------------------------#

find_pkg_dir() {
    local pkg pkg_dir softly
    pkg=$1
    softly=$2
    pkg_dir=( $REPO/*/$pkg(N) )
    if [[ $#pkg_dir == 0 && $softly != softly ]]
    then
        die "$pkg not found"
    fi
    print -- $pkg_dir[1]
}

#-----------------------------------------------------------------------------#

split_pkg_name() {
    # For speed, the results are left in the array `match'.
    if [[ ${1:t} =~ \(.*\)-\([^-]*\)-\([^-]*\)-\(.*\) ]]
    then
        return
    else
        match=( $longname UNKNOWN_VERSION )
    fi
}

same_version_installed() {
    local -r pkg=$1
    local -r pkg_dir=$(find_pkg_dir $pkg)
    local -r info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    local found
    found=( $PKGDB/$PRGNAM-$VERSION-*-*(N) )
    if [[ $#found > 0 ]]
    then
        return 0
    fi
    return 1
}

some_version_installed() {
    local -r pkg=$1
    local file
    for file in $PKGDB/${pkg}*(N)
    do
        split_pkg_name $file
        if [[ $match[1] == $pkg ]]
        then
            return 0
        fi
    done
    return 1
}

#-----------------------------------------------------------------------------#

excluded=()
seen=()
queue=()

is_excluded() {
    if [[ -n ${excluded[(re)$1]} ]]
    then
        return 0
    fi
    return 1
}

is_seen() {
    if [[ -n ${seen[(re)$1]} ]]
    then
        return 0
    fi
    return 1
}

in_queue() {
    if [[ -n ${queue[(re)$1]} ]]
    then
        return 0
    fi
    return 1
}

add_deps() {
    local pkg=$1
    if is_excluded $pkg
    then
        debug "$pkg excluded"
        return
    fi

    local pkg_dir=$(find_pkg_dir $pkg)
    [[ -d $pkg_dir ]] || exit 1
    local info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    seen+=$pkg
    debug "seen $pkg"
    local req
    for req in ${=REQUIRES}
    do
        if [[ $req == "%README%" ]]
        then
            continue
        fi
        if in_queue $req
        then
            debug "$req already queued"
            continue
        fi
        if is_seen $req
        then
            die "circular dependency detected: $req"
        fi
        add_deps $req
    done
    debug "$pkg queued"
    queue+=$pkg
}

#-----------------------------------------------------------------------------#

verify_file() {
    local md5=$1
    local fn=$2
    if [[ ! -f $fn ]]
    then
        debug "file does not exist: $fn"
        return 1
    fi
    # This extension is useful for certain custom slackbuilds.
    if [[ $md5 == UNKNOWN ]]
    then
        warn "MD5 sum is UNKNOWN; skipping check."
        return 0
    fi
    local digest=$( md5sum $fn | cut -d' ' -f1 )
    if [[ $digest == $md5 ]]
    then
        debug "file exists and verified: $fn"
        return 0
    else
        warn "MD5 sum does not match: $fn"
    fi
    return 1
}

percent_decode() {
    echo -e ${1//'%'/'\x'}
}

download_src() {
    local pkg=$1
    local pkg_dir=$(find_pkg_dir $pkg)
    local info=$pkg_dir/$pkg.info
    . $info # XXX makes a mess

    local md5s srcs
    if [[ $ARCH == x86_64 && $DOWNLOAD_x86_64 == UN* ]]
    then
        warn "$pkg is $DOWNLOAD_x86_64 on x86_64."
        srcs=( ${=DOWNLOAD} )
        md5s=( ${=MD5SUM} )
    elif [[ $ARCH == x86_64 && -n $DOWNLOAD_x86_64 ]]
    then
        srcs=( ${=DOWNLOAD_x86_64} )
        md5s=( ${=MD5SUM_x86_64} )
    else
        srcs=( ${=DOWNLOAD} )
        md5s=( ${=MD5SUM} )
    fi

    local -a srcfns
    while (( $#md5s > 0 ))
    do
        local src=$srcs[1]
        local md5=$md5s[1]
        local srcfn=$(percent_decode ${src:t})
        shift srcs
        shift md5s
        if (( $mode_forcedownload )) || ! verify_file $md5 $srcfn
        then
            debug "need to download: $srcfn"
            rm -f $srcfn
            if ! ${=WGET} $src
            then
                die "failed to download $src"
            fi
            if ! verify_file $md5 $srcfn
            then
                die "MD5 sum does not match: $srcfn"
            fi
        fi
        srcfns+=$srcfn
    done

    if (( $#dls > 0 ))
    then
        die "list length mismatch"
    fi

    print -l -- $srcfns
}

#-----------------------------------------------------------------------------#

maybe_fakeroot() {
    if [[ $UID != 0 && -x $FAKEROOT ]]
    then
        debug "running $FAKEROOT $@ in $PWD"
        command $FAKEROOT "$@"
        return $?
    else
        debug "running $@"
        command "$@"
        return $?
    fi
}

build() {
    local -r pkg=$1
    local -r pkg_dir=$(find_pkg_dir $pkg)
    local -r stagedir=$STAGEDIR/$pkg
    local -r builddir=$stagedir/build
    shift 1

    rm -rf $stagedir
    mkdir -p $stagedir
    cp -r $pkg_dir/* $stagedir
    local fn
    for fn in "$@"
    do
        ln -s $CACHEDIR/$fn $stagedir
    done

    local olddir=$PWD

    cd $stagedir
    if ! TMP=$builddir maybe_fakeroot $SLACKBUILD_SHELL $pkg.SlackBuild
    then
        die "error building $pkg"
    fi

    cd $olddir
}

#-----------------------------------------------------------------------------#

remove_stagedir() {
    local -r pkg=$1
    local -r pkg_dir=$(find_pkg_dir $pkg)
    local -r stagedir=$STAGEDIR/$pkg

    if [[ -d $stagedir ]]
    then
        if ! rm -rf $stagedir
        then
            die "error removing $stagedir"
        fi
        echo "Removed $stagedir"
    fi
}

#-----------------------------------------------------------------------------#

extract_built_pkg_filename() {
    local -r logfile=$1
    tail -3 $logfile | grep '^Slackware package .* created[.]$' | cut -d' ' -f3
}

maybe_sudo() {
    if [[ $UID != 0 && -x $SUDO ]]
    then
        debug "running $SUDO $@"
        command $SUDO "$@"
        return $?
    else
        debug "running $@"
        command "$@"
        return $?
    fi
}

install() {
    maybe_sudo /sbin/upgradepkg --install-new --reinstall $1
}

#-----------------------------------------------------------------------------#

# Parse options

mode_help=0
mode_print=0
mode_checkupdates=0
mode_dryrun=0
mode_download=0
mode_forcedownload=0
mode_build=0
mode_install=0
mode_cleanup=0
mode_rebase=0
mode_changelog=0
mode_search=0
mode_gensearch=0

while getopts hHcndDbirlsgx OPT
do
    case $OPT in
        (h)
            mode_help=1
            ;;
        (H)
            mode_print=1
            ;;
        (c)
            mode_checkupdates=1
            ;;
        (n)
            mode_dryrun=1
            ;;
        (d)
            mode_download=1
            ;;
        (D)
            mode_download=1
            mode_forcedownload=1
            ;;
        (b)
            mode_download=1
            mode_build=1
            ;;
        (i)
            mode_download=1
            mode_build=1
            mode_install=1
            ;;
        (x)
            mode_cleanup=1
            ;;
        (r)
            mode_rebase=1
            ;;
        (l)
            mode_changelog=1
            ;;
        (s)
            mode_search=1
            ;;
        (g)
            mode_gensearch=1
            ;;
        (?)
            die "unrecognised option"
            ;;
    esac
done
shift $(( $OPTIND - 1 ))

case $mode_checkupdates,$mode_download,$mode_build,$mode_install,$mode_cleanup,$mode_rebase,$mode_changelog,$mode_search,$mode_gensearch in
    (0,0,0,0,0,0,0,0,0)
        # Default to -i.
        mode_download=1
        mode_build=1
        mode_install=1
        ;;
esac

case $mode_download,$mode_cleanup in
    (1,1)
        die "-x is incompatible with -d, -b and -i"
        ;;
esac

case $mode_search,$mode_gensearch in
    (1,1)
        die "-s, -g both specified"
        ;;
esac

#-----------------------------------------------------------------------------#

# Help

if (( $mode_help ))
then
    cat << EOF
Usage: asbo [OPTION]... [PACKAGE]... [~EXCLUDE-PACKAGE]...
An anti-social SlackBuilds build order organiser.

  -h    display this help
  -H    print configuration

  -d    download sources for named packages and dependencies
  -D    force downloads (implies -d)
  -b    build named packages and dependencies (implies -d)
  -i    install named packages and dependencies (default; implies -b)
  -n    show packages that would be built
  -x    remove build directories for named packages

  -s    show information about named packages
  -g    general search for packages

  -r    run git rebase --pull in slackbuilds directory
  -l    show slackbuilds changelog
  -c    show potential updates to installed SBo packages

EOF
    exit
fi

#-----------------------------------------------------------------------------#

# Configuration

cfg=$HOME/.config/asbo/asbo.conf
if [[ ! -f $cfg ]]
then
    cfg=/etc/asbo/asbo.conf
fi
if [[ -f $cfg  ]]
then
    . =( grep -E -e '^(REPO|CACHEDIR|STAGEDIR|LOGDIR|OUTPUT|MAKEFLAGS|WGET)=' $cfg )
fi

prefix=/tmp/asbo
readonly REPO=${REPO:-${prefix}/slackbuilds}
readonly CACHEDIR=${CACHEDIR:-${prefix}/cache}
readonly STAGEDIR=${STAGEDIR:-${prefix}/stage}
readonly LOGDIR=${LOGDIR:-${prefix}/log}
readonly WGET=${WGET:-/usr/bin/wget}

export OUTPUT=${OUTPUT:-}
export MAKEFLAGS=${MAKEFLAGS:-}

#-----------------------------------------------------------------------------#

# Print configuration

if (( $mode_print ))
then
    print "REPO=$REPO"
    print "CACHEDIR=$CACHEDIR"
    print "STAGEDIR=$STAGEDIR"
    print "LOGDIR=$LOGDIR"
    print "OUTPUT=$OUTPUT"
    print "WGET=$WGET"
    print "MAKEFLAGS=$MAKEFLAGS"
    exit
fi

#-----------------------------------------------------------------------------#

# Set up repo

if [[ ! -e $REPO ]]
then
    print "Repository directory does not exist:  $REPO"
    print -n "Would you like to clone it with git now [y,n]? "
    read yn
    case $yn in
        ([yY])
            mkdir -p $REPO
            print "Cloning:  git clone $GIT_URL $REPO"
            git clone $GIT_URL $REPO
            ;;
        (*)
            die "Please set up the repository manually."
            exit 1
            ;;
    esac
fi

if [[ ! -d $REPO ]]
then
    die "$REPO is not a directory"
fi

#-----------------------------------------------------------------------------#

if (( $mode_rebase ))
then
    print "Updating repository:  git pull --rebase"
    cd $REPO
    exec git pull --rebase
fi

#-----------------------------------------------------------------------------#

if (( $mode_changelog ))
then
    cd $REPO
    exec ${=PAGER} ChangeLog.txt
fi

#-----------------------------------------------------------------------------#

search() {
    local glob dir
    # Interpret shell metacharacters in $1.
    glob=( $REPO/*/${~1}(/N) )
    if (( $#glob == 0 ))
    then
        print "No package found: $1"
        return 1
    fi
    for dir in $glob
    do
        (
            cd $dir
            echo "Package: ${dir:t}"
            echo
            if [[ -r README ]]
            then
                cat README
                echo
            fi
            echo "--------"
            echo
            cat *.info
            echo
            echo "--------"
            echo
            cat *.SlackBuild
        ) | ${=PAGER}
    done
}

if (( $mode_search ))
then
    for arg
    do
        search $arg
    done
    exit 0
fi

#-----------------------------------------------------------------------------#

gensearch() {(
    setopt no_case_glob
    cd $REPO
    glob=( */*${1}*(/N) )
    if (( $#glob == 0 ))
    then
        print "No package found: $1"
        return
    fi
    print -l -- $glob
)}

if (( $mode_gensearch ))
then
    for arg
    do
        gensearch $arg
    done
    exit 0
fi

#-----------------------------------------------------------------------------#

# Check updates

checkupdates() {
    local -a candidates
    if (( $# == 0 ))
    then
        candidates=( $PKGDB/*_SBo(N) )
    else
        local arg
        for arg
        do
            candidates+=( $PKGDB/*${arg}*SBo(N) )
        done
        if (( $#candidates == 0 ))
        then
            print "No installed packages matching: $@"
            return
        fi
    fi
    local file
    for file in $candidates
    do
        split_pkg_name $file
        local pkg=$match[1]
        local installed_version=$match[2]
        local pkg_dir=$(find_pkg_dir $pkg softly)
        if [[ ! -d $pkg_dir ]]
        then
            printf -- "%39s ->  %s\n" "(not found)" ${file:t}
            continue
        fi
        local info=$pkg_dir/$pkg.info
        . $info # XXX makes a mess

        if [[ $VERSION != $installed_version ]]
        then
            printf -- "%-39s ->  %s\n" "$pkg $VERSION" ${file:t}
        fi
    done
}

if (( $mode_checkupdates ))
then
    checkupdates "$@"
    exit 0
fi

#-----------------------------------------------------------------------------#

# Clean up mode

if (( $mode_cleanup ))
then
    for pkg
    do
        if ! remove_stagedir $pkg
        then
            exit 1
        fi
    done
    exit 0
fi

#-----------------------------------------------------------------------------#

top_pkgs=()
for pkg
do
    case $pkg in
        (~*) excluded+=${pkg#\~} ;;
        (*) top_pkgs+=$pkg ;;
    esac
done
debug "exclusions: $excluded"

for top_pkg in $top_pkgs
do
    add_deps $top_pkg
done
unset top_pkg

if (( $#queue == 0 ))
then
    die "No packages queued."
fi

if (( $mode_dryrun ))
then
    print "Would build packages in this order:"
    print "  $queue"
    exit 0
fi

mkdir -p $CACHEDIR
mkdir -p $STAGEDIR
mkdir -p $LOGDIR

for pkg in $queue
do
    if [[ -n ${top_pkgs[(re)$pkg]} ]]
    then
        if same_version_installed $pkg
        then
            print -- "$pkg (same version) already installed."
            print -n -- "Process anyway [y,n]? "
            read yn
            case $yn in
                ([yY]) ;;
                (*)
                    echo "Skipping $pkg."
                    continue
                    ;;
            esac
        fi
    elif some_version_installed $pkg
    then
        print -- "$pkg already installed, skipping."
        continue
    fi

    cd $CACHEDIR
    local logfile=$LOGDIR/$pkg.log
    local -a srcfns
    srcfns=($( download_src $pkg ))

    if (( $mode_build ))
    then
        print "Building $pkg"
        if ! build $pkg $srcfns >& /dev/stdout >& $logfile
        then
            die "build failed"
        fi
    fi

    remove_stagedir $pkg
    print

    if (( $mode_install ))
    then
        print "Installing $pkg (enter sudo password if required)"
        install $(extract_built_pkg_filename $logfile)
    fi
done

#-----------------------------------------------------------------------------#
# vim: set sts=4 sw=4 et:
